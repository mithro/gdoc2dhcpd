# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Build and Test Commands

```bash
uv run pytest                           # Run all tests
uv run pytest tests/test_models/        # Run tests for a specific module
uv run pytest tests/test_models/test_addressing.py::test_mac_parse  # Run single test
uv run pytest -x                        # Stop on first failure
uv run ruff check src/ tests/           # Lint
uv run gdoc2netcfg fetch                # Download CSVs from Google Sheets
uv run gdoc2netcfg generate dnsmasq_internal  # Generate internal dnsmasq config
uv run gdoc2netcfg generate dnsmasq_external  # Generate external dnsmasq config
uv run gdoc2netcfg generate letsencrypt       # Generate certbot cert scripts
uv run gdoc2netcfg generate nagios            # Generate Nagios monitoring config
uv run gdoc2netcfg generate nginx             # Generate nginx reverse proxy configs
uv run gdoc2netcfg generate topology          # Generate Graphviz DOT topology diagram
uv run gdoc2netcfg validate             # Run constraint validation
uv run gdoc2netcfg info                 # Show pipeline configuration
uv run gdoc2netcfg reachability         # Ping all hosts and report up/down
uv run gdoc2netcfg sshfp --force        # Scan SSH fingerprints
uv run gdoc2netcfg ssl-certs --force    # Scan SSL/TLS certificates
uv run gdoc2netcfg snmp-host --force    # Scan hosts for SNMP system info
uv run gdoc2netcfg snmp-switch --force  # Scan switches for bridge/topology via SNMP
uv run gdoc2netcfg bmc-firmware --force # Probe BMC firmware versions via ipmitool
uv run gdoc2netcfg bridge              # Unified switch data (SNMP + NSDP)
uv run gdoc2netcfg nsdp                # Scan Netgear switches via NSDP
uv run gdoc2netcfg cron                # Manage scheduled cron jobs
```

Always use `uv run` to execute Python commands. Never use bare `python` or `pip`.

## Development Workflow

Make small, discrete commits as you work. Each logical unit of change (adding a helper function, wiring a parameter through the call chain, adding tests, updating docs) should be its own commit. Don't batch all changes into a single commit at the end.

### Fail Loud, Never Fabricate

**Never make up data.** If a value can't be resolved, computed, or looked up — raise an error. Don't generate synthetic placeholders, fallback names, or default values that hide the problem. Examples of things to never do:
- Generating a fake port name like `f"port{bridge_port}"` when an ifIndex lookup fails
- Substituting a default value when a required field is missing
- Silently returning `None` or an empty result when something unexpected happens

**Never silently discard data.** If a record, entry, or value can't be processed — raise an error. Don't skip it with `continue` or filter it out. Every piece of input data matters and unexpected data indicates a bug or a gap in our understanding that needs investigation.

**Fail early and loud** so problems surface immediately and get fixed at the root cause. Silent fallbacks and graceful degradation turn small bugs into hard-to-diagnose data quality issues.

## Architecture

`gdoc2netcfg` reads network device data from a Google Spreadsheet and generates configuration files for network infrastructure services (dnsmasq, Nagios, nginx).

### Pipeline

The system is a data pipeline in `src/gdoc2netcfg/`:

```
Sources (sources/)     Fetch CSV from Google Sheets, cache locally, parse into DeviceRecord
    │                  Also parses VLAN Allocations sheet (vlan_parser.py)
    │
Derivations (derivations/)  Pure functions: IPv4→IPv6, IP→VLAN, hostname, DHCP name, DNS names,
    │                        default IP, hardware type detection, site IP remapping
    │                        host_builder.py orchestrates these into Host objects
    │
Supplements (supplements/)  External enrichment (all cached to .cache/):
    │                        SSHFP (ssh-keyscan), SSL certs, SNMP host info, SNMP bridge/topology,
    │                        BMC firmware (ipmitool), NSDP switch discovery, reachability (ping)
    │
Constraints (constraints/)  Validation: field presence, BMC placement, MAC uniqueness,
    │                        IPv6 consistency, bridge/topology, SNMP availability, SSL certs
    │
Generators (generators/)    Output: dnsmasq_internal, dnsmasq_external, nagios, nginx,
    │                        letsencrypt, topology (Graphviz DOT)
    │
Config files               Per-host .conf files in output directories
```

Supporting modules:
- `utils/` — shared helpers: IP sort/classification (`ip.py`), DNS/path injection guards (`dns.py`), terminal colours (`terminal.py`)
- `audit/` — compare spreadsheet data against live network state

The CLI (`cli/main.py`) wires the pipeline via `_build_pipeline()` which returns `(records, hosts, inventory, validation_result)`. Generators receive a `NetworkInventory` — the fully enriched model with all derivations applied.

### Key Data Flow

1. `sources/parser.py` parses CSV rows into `DeviceRecord` (machine, mac, ip, interface)
2. `derivations/host_builder.py::build_hosts()` groups records by machine name into `Host` objects, each with multiple `NetworkInterface` entries
3. `derivations/dns_names.py::derive_all_dns_names()` computes all DNS name variants per host (hostname, interface, subdomain, ipv4/ipv6 prefix variants)
4. `build_inventory()` creates `NetworkInventory` with precomputed `ip_to_hostname` and `ip_to_macs` indexes
5. Generators consume `NetworkInventory` to produce config files

### BMC Handling

BMCs (Baseboard Management Controllers) are physically separate machines attached to a primary host. When a spreadsheet row has interface="bmc" on machine="big-storage", `build_hosts()` creates a separate host `bmc.big-storage` — not a sub-interface. The BMC gets its own hostname, DNS records, DHCP binding, and PTR entry.

### IPv4→IPv6 Mapping

Dual-stack addressing uses the scheme: `10.AA.BB.CCC` → `{prefix}AABB::CCC` where AA is unpadded and BB is zero-padded to 2 digits. Prefixes are configured under `[ipv6]` in the site's `gdoc2netcfg.toml`.

### Split-Horizon DNS

The dnsmasq generator has internal and external variants. Both produce per-host `.conf` files and share PTR, host-record, CAA, and SSHFP generation via `dnsmasq_common.py`. The internal generator additionally produces DHCP host bindings. External (`dnsmasq_external.py`) replaces RFC 1918 IPs with the site's public IPv4 address in host-record entries for external-facing DNS. PTR records use the original IPs in both variants (IPv4 PTRs use RFC 1918 addresses; IPv6 PTRs use globally routable addresses).

### Let's Encrypt Certificates

The letsencrypt generator (`letsencrypt.py`) produces per-host certbot scripts in `certs-available/{primary_fqdn}` and a `renew-enabled.sh` orchestrator. Uses DNS-01 challenge validation via the `certbot-hook-dnsmasq` Python CLI (`certbot-hook-dnsmasq auth-hook`) that manages `_acme-challenge` TXT records in the external dnsmasq instance. Dnsmasq connection parameters (`--conf-dir`, `--conf`, `--service`) are passed as CLI flags on the auth hook command rather than environment variables. Deploy hooks are added based on `hardware_type` (e.g. supermicro-bmc, netgear-switch). Only public FQDNs (`is_fqdn=True`) are included as `-d` domains.

### Nginx Reverse Proxy

The nginx generator (`nginx.py`) produces per-host reverse proxy server blocks under `sites-available/`. Each host gets four config file variants: `{fqdn}-http-public`, `{fqdn}-http-private`, `{fqdn}-https-public`, `{fqdn}-https-private`.

Multi-interface hosts get a combined config file (per variant) containing an `upstream` block listing all interface IPs for round-robin failover with `proxy_next_upstream`, a root server block using the upstream, and per-interface server blocks with direct `proxy_pass`. Single-interface hosts produce simple direct `proxy_pass` configs.

### Network Topology

The topology generator (`topology.py`) produces a Graphviz DOT diagram of the physical network from bridge supplement data. Switch nodes (hosts with bridge data) are boxes; host nodes (whose MACs appear in switch MAC tables) are ellipses. LLDP-learned edges are bold and bidirectional; MAC-learned edges are dashed. Locally administered MACs are filtered out.

### Configuration

`gdoc2netcfg.toml` (gitignored, site-specific) defines site topology (domain, VLANs, IPv6 prefixes, network subdomains), sheet URLs, cache directory, and generator settings. Loaded by `config.py` into a `PipelineConfig` dataclass containing a `Site` object.

`gdoc2netcfg.toml.example` is the tracked template with Welland defaults. Each site copies it to `gdoc2netcfg.toml` and edits the `[site]`, `[ipv6]`, and `[generators] enabled` sections. This avoids merge conflicts when deploying to Monarto.

### Models

- `MACAddress`, `IPv4Address`, `IPv6Address` — frozen, validated, normalized value types in `models/addressing.py`
- `Host` — groups `NetworkInterface` entries for one machine, with default IP selection; `VirtualInterface` for derived interfaces
- `NetworkInventory` — the complete enriched model passed to generators
- `VLAN`, `Site` — network topology definitions in `models/network.py`, loaded from config + VLAN Allocations sheet
- `PortLinkStatus`, `PortTrafficStats`, `SwitchData`, `SwitchDataSource` — unified switch data model in `models/switch_data.py`, populated from SNMP or NSDP sources

### NSDP Protocol Library

`src/nsdp/` is a standalone pure-Python implementation of the Netgear Switch Discovery Protocol (NSDP). It has no external dependencies. The `supplements/nsdp.py` module bridges this library into the gdoc2netcfg supplement pipeline. See `docs/nsdp-protocol.md` for the protocol specification.

## Production Deployment

Deployed on two sites, both at `/opt/gdoc2netcfg/`:

| Site | Host | IP scheme | IPv6 prefix | Generators |
|------|------|-----------|-------------|------------|
| welland | `ten64.welland.mithis.com` (10.1.10.1) | `10.1.X.X` | `2404:e80:a137:1XX::` | internal, external, nagios, nginx |
| monarto | `ten64.monarto.mithis.com` (10.2.10.1) | `10.2.X.X` | `2404:e80:a137:2XX::` | internal only |

Both sites share the same Google Spreadsheet. The spreadsheet uses `10.X.Y.Z` (literal `X` in the second octet) for devices that exist at multiple sites, and a "Site" column to restrict records to a specific site. The `site_octet` in each site's `gdoc2netcfg.toml` replaces the `X` placeholder.

### Deploying code changes

Use SSH agent forwarding and `sudo -E` so that `git pull` can authenticate via the forwarded SSH key:

```bash
# Welland
ssh -A ten64.welland.mithis.com "cd /opt/gdoc2netcfg && sudo -E git pull"

# Monarto (via WireGuard tunnel)
ssh -o ControlPath=none -o ForwardAgent=yes tim@10.255.0.2 \
  "cd /opt/gdoc2netcfg && sudo -E git pull"
```

`git pull` is clean on both sites — `gdoc2netcfg.toml` is gitignored, so each site's local config is never touched by pulls. If a site doesn't have a local config yet, create one after pulling:

```bash
cp gdoc2netcfg.toml.example gdoc2netcfg.toml
# Edit [site], [ipv6], and [generators] enabled for this site
```

Note: `uv` on monarto is at `~/.local/bin/uv` (not in PATH for non-interactive shells).

### dnsmasq

#### Directory layout

dnsmasq instances run via systemd template units (`dnsmasq@internal`, `dnsmasq@external`). Each instance has a top-level config at `/etc/dnsmasq.d/dnsmasq.{instance}.conf` with `conf-dir` directives:

```
/etc/dnsmasq.d/
  dnsmasq.internal.conf          # conf-dir=shared, internal, internal/generated
  dnsmasq.external.conf          # conf-dir=shared, external, external/generated (welland only)
  shared/                        # Shared config (base, upstream, logging, edns)
  internal/
    00-listen.conf               # Listen addresses, bind-dynamic
    02-cross-site.conf           # Cross-site DNS forwarding via WireGuard
    03-auth-server.conf          # Auth DNS server config
    04-dhcp-global.conf          # DHCP global settings
    network-*.conf               # Per-VLAN DHCP ranges and domains
    override-*.conf              # Manual per-device overrides
    generated/                   # ← gdoc2netcfg output (wipe-and-replace safe)
      ten64.conf
      desktop.conf
      ...
  external/                      # Welland only
    00-listen.conf
    03-auth-dns.conf
    dnsmasq.acme.*.conf          # ACME challenge records
    generated/                   # ← gdoc2netcfg output (wipe-and-replace safe)
      ...
```

Hand-crafted configs live in `internal/` and `external/`. Generated per-host configs live in `internal/generated/` and `external/generated/`. The `generated/` subdirectories can be wiped and replaced without affecting manual configs.

#### Fetch, generate, and deploy

```bash
# On each site:
cd /opt/gdoc2netcfg
uv run gdoc2netcfg fetch
uv run gdoc2netcfg generate --force

# Deploy (wipe old generated configs, copy new ones)
sudo rm -f /etc/dnsmasq.d/internal/generated/*.conf
sudo cp internal/*.conf /etc/dnsmasq.d/internal/generated/
sudo systemctl restart dnsmasq@internal

# Welland also has external:
sudo rm -f /etc/dnsmasq.d/external/generated/*.conf
sudo cp external/*.conf /etc/dnsmasq.d/external/generated/
sudo systemctl restart dnsmasq@external
```

#### Cross-site DNS forwarding

The two sites forward DNS queries to each other via WireGuard tunnel (`10.255.0.1` welland, `10.255.0.2` monarto). Each site's `02-cross-site.conf` contains `server=` directives to forward the other site's domains, reverse IPv4 zones (`X.10.in-addr.arpa`), and reverse IPv6 zones through the tunnel.

### nginx

Generated nginx configs are written to `/etc/nginx/sites-available/` and activated via symlinks in `/etc/nginx/sites-enabled/`. Welland only.

### Let's Encrypt

Certbot scripts are generated to `/opt/gdoc2netcfg/letsencrypt/`. Welland only.

```bash
sudo uv run gdoc2netcfg generate --output-dir /opt/gdoc2netcfg letsencrypt
sudo sh /opt/gdoc2netcfg/letsencrypt/certs-available/{fqdn}  # Provision a cert
```

The auth hook is the `certbot-hook-dnsmasq` Python CLI installed at `/opt/certbot/bin/certbot-hook-dnsmasq` (separate repo: `mithro/certbot-hook-dnsmasq`). It creates TXT records in the external dnsmasq, verifies local resolution, sends NOTIFY to secondaries, and polls until they sync.

### Other

The SSHFP cache lives at `.cache/sshfp.json`.
