#!/usr/bin/env python3
"""
Generate tc rules for MAC-based VLAN tagging on br-raw

Usage:
    ./tc-mac-vlan.py                    # Show MAC-to-VLAN mappings
    ./tc-mac-vlan.py --tc               # Generate tc rules for br-raw
    ./tc-mac-vlan.py --json             # Output as JSON
"""

import json
import sys
import os

# IP subnet to VLAN mapping
# Based on /etc/systemd/network/br-*.network configurations
SUBNET_TO_VLAN = {
    # 10.1.X.Y subnets
    (10, 1, 1): 1,      # tmp
    (10, 1, 5): 5,      # net (management)
    (10, 1, 6): 6,      # pwr
    (10, 1, 20): 20,    # roam
    (10, 1, 90): 90,    # iot
    (10, 1, 99): 99,    # guest
    # 10.1.10-17.x handled specially (br-int /21)
    # 10.X.Y.Z subnets (different second octet)
    (10, 31): 31,       # sm
    (10, 41): 41,       # fpgas
}

VLAN_NAMES = {
    1: 'tmp',
    5: 'net',
    6: 'pwr',
    10: 'int',
    20: 'roam',
    31: 'sm',
    41: 'fpgas',
    90: 'iot',
    99: 'guest',
}

def ip_to_vlan(ip_str):
    """Convert IP address to VLAN ID."""
    parts = [int(x) for x in ip_str.split('.')]
    if len(parts) != 4:
        return None

    a, b, c, d = parts

    if a != 10:
        return None

    # Check for non-1 second octet (sm, fpgas)
    if b == 31:
        return 31
    if b == 41:
        return 41

    if b != 1:
        return None

    # 10.1.X.Y - check third octet
    if c == 1:
        return 1   # tmp
    if c == 5:
        return 5   # net
    if c == 6:
        return 6   # pwr
    if c == 20:
        return 20  # roam
    if c == 90:
        return 90  # iot
    if c == 99:
        return 99  # guest

    # 10.1.10-17.x = br-int (VLAN 10)
    if 10 <= c <= 17:
        return 10

    return None

def load_macs():
    """Load MAC addresses from macs.json."""
    script_dir = os.path.dirname(os.path.abspath(__file__))
    macs_file = os.path.join(script_dir, 'macs.json')

    with open(macs_file) as f:
        return json.load(f)

def get_mac_vlan_mappings():
    """Get all MAC to VLAN mappings."""
    macs_data = load_macs()
    seen_macs = {}  # mac -> first occurrence info
    duplicates = []
    mappings = []

    for ip, mac_list in macs_data.items():
        vlan = ip_to_vlan(ip)
        if vlan is None:
            continue

        for mac_info in mac_list:
            mac = mac_info[0].lower()
            name = mac_info[1] if len(mac_info) > 1 else ''

            # Skip bridge MACs (these are our own interfaces)
            if mac.startswith('02:00:0a:01:'):
                continue

            # Check for duplicates
            if mac in seen_macs:
                duplicates.append({
                    'mac': mac,
                    'ip': ip,
                    'name': name,
                    'first_ip': seen_macs[mac]['ip'],
                    'first_name': seen_macs[mac]['name'],
                })
                continue

            entry = {
                'mac': mac,
                'ip': ip,
                'vlan': vlan,
                'vlan_name': VLAN_NAMES.get(vlan, str(vlan)),
                'name': name,
            }
            seen_macs[mac] = entry
            mappings.append(entry)

    # Error on duplicates
    if duplicates:
        print(f"ERROR: {len(duplicates)} duplicate MAC(s) in macs.json:", file=sys.stderr)
        for d in duplicates:
            print(f"  {d['mac']}: {d['ip']} ({d['name']}) duplicates {d['first_ip']} ({d['first_name']})", file=sys.stderr)
        sys.exit(1)

    return mappings

def generate_tc_rules(mappings, bridge='br-raw'):
    """Generate tc rules for MAC-based VLAN tagging on the bridge."""
    lines = [
        '#!/bin/bash',
        f'# MAC-based VLAN tagging rules for {bridge}',
        '# Generated by tc-mac-vlan.py',
        '#',
        '# Priority 1: Pass already-tagged traffic unchanged',
        '# Priority 2: Tag untagged frames from specific source MACs',
        '# Egress: Strip tags from frames going to specific destination MACs',
        '',
    ]

    # Setup clsact qdisc on the bridge (supports both ingress and egress)
    lines.append(f'tc qdisc del dev {bridge} clsact 2>/dev/null || true')
    lines.append(f'tc qdisc add dev {bridge} clsact')

    lines.append('')
    lines.append('# Priority 1: Pass tagged traffic through unchanged')
    lines.append(f'tc filter add dev {bridge} ingress prio 1 protocol 802.1Q flower action pass')

    lines.append('')
    lines.append('# Priority 2: Tag untagged frames based on source MAC')

    # Group by VLAN for cleaner output
    by_vlan = {}
    for m in mappings:
        vlan = m['vlan']
        if vlan not in by_vlan:
            by_vlan[vlan] = []
        by_vlan[vlan].append(m)

    # Add ingress rules (tag based on source MAC) at priority 2
    for vlan in sorted(by_vlan.keys()):
        vlan_name = VLAN_NAMES.get(vlan, str(vlan))
        lines.append(f'')
        lines.append(f'# VLAN {vlan} ({vlan_name})')

        for m in sorted(by_vlan[vlan], key=lambda x: x['mac']):
            mac = m['mac']
            name = m['name']
            lines.append(f'tc filter add dev {bridge} ingress prio 2 protocol all flower src_mac {mac} action vlan push id {vlan}  # {name}')

    lines.append('')
    lines.append('# Egress rules: strip tags for destination MACs')

    # Add egress rules (strip tags based on destination MAC)
    for vlan in sorted(by_vlan.keys()):
        vlan_name = VLAN_NAMES.get(vlan, str(vlan))
        lines.append(f'')
        lines.append(f'# VLAN {vlan} ({vlan_name})')

        for m in sorted(by_vlan[vlan], key=lambda x: x['mac']):
            mac = m['mac']
            name = m['name']
            lines.append(f'tc filter add dev {bridge} egress prio 1 protocol 802.1Q flower dst_mac {mac} action vlan pop  # {name}')

    lines.append('')
    lines.append('echo "MAC-based VLAN rules applied successfully"')

    return '\n'.join(lines)

def main():
    mappings = get_mac_vlan_mappings()

    if '--tc' in sys.argv:
        print(generate_tc_rules(mappings))
    elif '--json' in sys.argv:
        print(json.dumps(mappings, indent=2))
    else:
        # Default: show summary
        print(f"{'MAC':<20} {'VLAN':<6} {'Name':<30} {'IP'}")
        print('-' * 80)
        for m in sorted(mappings, key=lambda x: (x['vlan'], x['mac'])):
            print(f"{m['mac']:<20} {m['vlan']:<6} {m['name']:<30} {m['ip']}")

        print(f"\nTotal: {len(mappings)} MAC addresses")

        # Summary by VLAN
        by_vlan = {}
        for m in mappings:
            vlan = m['vlan']
            by_vlan[vlan] = by_vlan.get(vlan, 0) + 1

        print("\nBy VLAN:")
        for vlan in sorted(by_vlan.keys()):
            name = VLAN_NAMES.get(vlan, '')
            print(f"  VLAN {vlan:>2} ({name:<6}): {by_vlan[vlan]} MACs")

if __name__ == '__main__':
    main()
