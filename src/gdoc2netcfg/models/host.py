"""Host models: network interfaces, hosts, and the full inventory."""

from __future__ import annotations

from dataclasses import dataclass, field

from gdoc2netcfg.models.addressing import IPv4Address, IPv6Address, MACAddress
from gdoc2netcfg.models.network import Site


@dataclass(frozen=True)
class DNSName:
    """A DNS name with its associated IP addresses.

    Each DNS name maps to a specific IPv4 address and zero or more
    IPv6 addresses. The is_fqdn flag distinguishes full domain names
    (e.g. 'big-storage.welland.mithis.com') from short names
    (e.g. 'big-storage').
    """

    name: str
    ipv4: IPv4Address | None = None
    ipv6_addresses: tuple[IPv6Address, ...] = ()
    is_fqdn: bool = False


@dataclass(frozen=True)
class NetworkInterface:
    """A single network interface on a host.

    Attributes:
        name: Interface name (e.g. 'eth0', 'bmc'), or None for the default/only interface
        mac: Ethernet MAC address
        ipv4: IPv4 address
        ipv6_addresses: IPv6 addresses generated from the IPv4
        vlan_id: VLAN this interface belongs to (derived from IP)
        dhcp_name: Name used for DHCP registration
    """

    name: str | None
    mac: MACAddress
    ipv4: IPv4Address
    ipv6_addresses: list[IPv6Address] = field(default_factory=list)
    vlan_id: int | None = None
    dhcp_name: str = ""


@dataclass(frozen=True)
class VirtualInterface:
    """A logical network endpoint grouping physical NICs that share an IP.

    When a device has multiple physical interfaces (e.g. wired + wireless)
    with the same IPv4, they are grouped into one VirtualInterface.
    Single-NIC endpoints produce a VirtualInterface with one MAC.

    Attributes:
        name: Interface name from the first physical NIC (None for default).
        ipv4: The shared IPv4 address.
        macs: All MAC addresses for this IP (tuple for immutability).
        dhcp_names: DHCP names from all physical NICs (tuple for immutability).
        ipv6_addresses: IPv6 addresses (from the first physical NIC).
        vlan_id: VLAN ID (from the first physical NIC).
    """

    name: str | None
    ipv4: IPv4Address
    macs: tuple[MACAddress, ...]
    dhcp_names: tuple[str, ...] = ()
    ipv6_addresses: list[IPv6Address] = field(default_factory=list)
    vlan_id: int | None = None


@dataclass(frozen=True)
class SSLCertInfo:
    """SSL/TLS certificate information for a host.

    Populated by the ssl_certs supplement after scanning port 443.
    """

    issuer: str
    self_signed: bool
    valid: bool
    expiry: str
    sans: tuple[str, ...] = ()


@dataclass(frozen=True)
class SNMPData:
    """SNMP data collected from a host.

    Populated by the snmp supplement after querying SNMP agents.
    All fields use immutable types (tuples of tuples) to match the
    frozen dataclass guarantee.

    Attributes:
        snmp_version: Protocol version used ("v1", "v2c", or "v3").
        system_info: System group key-value pairs (sysDescr, sysName, etc.).
        interfaces: ifTable rows, each row as key-value pairs.
        ip_addresses: ipAddrTable rows, each row as key-value pairs.
        raw: All collected OID→value pairs for extensibility.
    """

    snmp_version: str
    system_info: tuple[tuple[str, str], ...] = ()
    interfaces: tuple[tuple[tuple[str, str], ...], ...] = ()
    ip_addresses: tuple[tuple[tuple[str, str], ...], ...] = ()
    raw: tuple[tuple[str, str], ...] = ()


@dataclass(frozen=True)
class BMCFirmwareInfo:
    """BMC firmware information from ipmitool mc info.

    Populated by the bmc_firmware supplement after probing Supermicro BMCs.

    Attributes:
        product_name: Board model from ipmitool (e.g. "X11SPM-T(P)F").
        firmware_revision: BMC firmware version (e.g. "1.74").
        ipmi_version: IPMI protocol version (e.g. "2.0").
        series: Supermicro series number extracted from product_name
            (e.g. 11 for X11, 9 for X9), or None if not parseable.
        snmp_capable: Whether this BMC series supports SNMP.
            True for X10+ (AST2400/2500/2600), False for X9 and earlier
            (ATEN WPCM450).
    """

    product_name: str
    firmware_revision: str
    ipmi_version: str
    series: int | None
    snmp_capable: bool


@dataclass(frozen=True)
class BridgeData:
    """Switch bridge/topology data collected via SNMP.

    Populated by the bridge supplement for managed switches.
    Contains MAC address table, VLAN configuration, LLDP neighbors,
    and port status. All fields use immutable types.

    Attributes:
        mac_table: (mac_str, vlan_id, bridge_port, port_name) tuples.
        vlan_names: (vlan_id, name) tuples from dot1qVlanStaticName.
        port_pvids: (ifIndex, pvid) tuples from dot1qPvid.
        port_names: (ifIndex, name) tuples from ifName.
        port_status: (ifIndex, oper_status, speed_mbps) tuples.
        lldp_neighbors: (local_ifIndex, remote_sysname, remote_port_id,
            remote_chassis_mac) tuples.
        vlan_egress_ports: (vlan_id, port_bitmap_hex) tuples for tagged membership.
        vlan_untagged_ports: (vlan_id, port_bitmap_hex) tuples for untagged membership.
        poe_status: (ifIndex, admin_status, detection_status) tuples.
    """

    mac_table: tuple[tuple[str, int, int, str], ...] = ()
    vlan_names: tuple[tuple[int, str], ...] = ()
    port_pvids: tuple[tuple[int, int], ...] = ()
    port_names: tuple[tuple[int, str], ...] = ()
    port_status: tuple[tuple[int, int, int], ...] = ()
    lldp_neighbors: tuple[tuple[int, str, str, str], ...] = ()
    vlan_egress_ports: tuple[tuple[int, str], ...] = ()
    vlan_untagged_ports: tuple[tuple[int, str], ...] = ()
    poe_status: tuple[tuple[int, int, int], ...] = ()


@dataclass
class Host:
    """A logical host with one or more network interfaces.

    Built by aggregating raw device records that share the same machine name.

    Attributes:
        machine_name: Raw machine name from the spreadsheet
        hostname: Computed hostname (may include suffix like '.iot')
        sheet_type: Which spreadsheet sheet this came from ('Network', 'IoT', etc.)
        interfaces: All network interfaces for this host
        default_ipv4: The primary IPv4 address for bare hostname resolution
        subdomain: Network subdomain (e.g. 'int', 'iot', 'net')
        sshfp_records: SSH fingerprint records (populated by supplement)
        extra: Additional spreadsheet columns preserved for generators
    """

    machine_name: str
    hostname: str
    sheet_type: str = "Network"
    interfaces: list[NetworkInterface] = field(default_factory=list)
    default_ipv4: IPv4Address | None = None
    subdomain: str | None = None
    sshfp_records: list[str] = field(default_factory=list)
    extra: dict[str, str] = field(default_factory=dict)
    alt_names: list[str] = field(default_factory=list)
    dns_names: list[DNSName] = field(default_factory=list)
    hardware_type: str | None = None
    ssl_cert_info: SSLCertInfo | None = None
    snmp_data: SNMPData | None = None
    bmc_firmware_info: BMCFirmwareInfo | None = None
    bridge_data: BridgeData | None = None

    @property
    def interface_by_name(self) -> dict[str | None, NetworkInterface]:
        """Map interface names to interfaces."""
        return {iface.name: iface for iface in self.interfaces}

    @property
    def all_ipv4(self) -> dict[str | None, IPv4Address]:
        """Map interface names to their IPv4 addresses."""
        return {iface.name: iface.ipv4 for iface in self.interfaces}

    @property
    def all_macs(self) -> list[MACAddress]:
        """All MAC addresses across all interfaces."""
        return [iface.mac for iface in self.interfaces]

    def is_bmc(self) -> bool:
        """Check if any interface is a BMC (Baseboard Management Controller)."""
        return any(
            iface.name and 'bmc' in iface.name.lower()
            for iface in self.interfaces
        )

    @property
    def virtual_interfaces(self) -> list[VirtualInterface]:
        """Group physical interfaces by IPv4 into logical endpoints.

        Interfaces sharing the same IPv4 (e.g. wired + wireless on the
        same device) are combined into one VirtualInterface with multiple
        MACs.  Order follows first occurrence in self.interfaces.
        """
        from collections import OrderedDict

        groups: OrderedDict[str, list[NetworkInterface]] = OrderedDict()
        for iface in self.interfaces:
            key = str(iface.ipv4)
            groups.setdefault(key, []).append(iface)
        result = []
        for ifaces in groups.values():
            first = ifaces[0]
            result.append(VirtualInterface(
                name=first.name,
                ipv4=first.ipv4,
                macs=tuple(i.mac for i in ifaces),
                dhcp_names=tuple(i.dhcp_name for i in ifaces),
                ipv6_addresses=first.ipv6_addresses,
                vlan_id=first.vlan_id,
            ))
        return result

    def is_multi_interface(self) -> bool:
        """Check if this host has multiple distinct IP endpoints."""
        return len(self.virtual_interfaces) > 1


@dataclass
class NetworkInventory:
    """The fully enriched network data model.

    This is the output of the pipeline's derivation and supplement stages,
    and the input to all generators. Contains the site configuration, all
    hosts, and precomputed indexes for efficient lookup.

    Attributes:
        site: Site topology configuration
        hosts: All hosts in the inventory
        ip_to_hostname: Precomputed IP→hostname mapping
        ip_to_macs: Precomputed IP→[(mac, dhcp_name)] mapping
    """

    site: Site
    hosts: list[Host] = field(default_factory=list)
    ip_to_hostname: dict[str, str] = field(default_factory=dict)
    ip_to_macs: dict[str, list[tuple[MACAddress, str]]] = field(default_factory=dict)

    def hosts_sorted(self) -> list[Host]:
        """Return hosts sorted by reversed hostname components.

        This matches the existing dnsmasq.py sort order for host-record output.
        """
        return sorted(self.hosts, key=lambda h: h.hostname.split('.')[::-1])

    def host_by_hostname(self, hostname: str) -> Host | None:
        """Look up a host by its hostname."""
        for host in self.hosts:
            if host.hostname == hostname:
                return host
        return None
