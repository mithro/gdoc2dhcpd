"""Linux tc MAC-based VLAN tagging rules generator.

Produces a shell script with tc filter commands for MAC-based VLAN
tagging on a Linux bridge (default: br-raw).

Extracted from tc-mac-vlan.py.
"""

from __future__ import annotations

from gdoc2netcfg.models.host import NetworkInventory


BRIDGE_MAC_PREFIX = "02:00:0a:01:"  # Skip bridge MACs

# VLAN name lookup (same as cisco_sg300)
def _get_vlan_name(vlan: int, inventory: NetworkInventory) -> str:
    if vlan in inventory.site.vlans:
        return inventory.site.vlans[vlan].name
    return str(vlan)


def generate_tc_mac_vlan(inventory: NetworkInventory, bridge: str = "br-raw") -> str:
    """Generate tc rules for MAC-based VLAN tagging on a bridge."""
    # Build MAC-to-VLAN mappings
    mappings: list[dict[str, object]] = []
    seen: set[str] = set()

    for host in inventory.hosts:
        for iface in host.interfaces:
            if iface.vlan_id is None:
                continue
            mac_str = str(iface.mac)
            if mac_str.startswith(BRIDGE_MAC_PREFIX):
                continue
            if mac_str in seen:
                continue
            seen.add(mac_str)
            mappings.append({
                "mac": mac_str,
                "vlan": iface.vlan_id,
                "name": iface.dhcp_name,
            })

    # Group by VLAN
    by_vlan: dict[int, list[dict[str, object]]] = {}
    for m in mappings:
        vlan = m["vlan"]
        assert isinstance(vlan, int)
        by_vlan.setdefault(vlan, []).append(m)

    lines = [
        "#!/bin/bash",
        f"# MAC-based VLAN tagging rules for {bridge}",
        "# Generated by gdoc2netcfg",
        "#",
        "# Priority 1: Pass already-tagged traffic unchanged",
        "# Priority 2: Tag untagged frames from specific source MACs",
        "# Egress: Strip tags from frames going to specific destination MACs",
        "",
        f"tc qdisc del dev {bridge} clsact 2>/dev/null || true",
        f"tc qdisc add dev {bridge} clsact",
        "",
        "# Priority 1: Pass tagged traffic through unchanged",
        f"tc filter add dev {bridge} ingress prio 1 protocol 802.1Q flower action pass",
        "",
        "# Priority 2: Tag untagged frames based on source MAC",
    ]

    # Ingress rules
    for vlan in sorted(by_vlan.keys()):
        vlan_name = _get_vlan_name(vlan, inventory)
        lines.append("")
        lines.append(f"# VLAN {vlan} ({vlan_name})")
        for m in sorted(by_vlan[vlan], key=lambda x: str(x["mac"])):
            mac = m["mac"]
            name = m["name"]
            lines.append(
                f"tc filter add dev {bridge} ingress prio 2 protocol all "
                f"flower src_mac {mac} action vlan push id {vlan}  # {name}"
            )

    # Egress rules
    lines.append("")
    lines.append("# Egress rules: strip tags for destination MACs")
    for vlan in sorted(by_vlan.keys()):
        vlan_name = _get_vlan_name(vlan, inventory)
        lines.append("")
        lines.append(f"# VLAN {vlan} ({vlan_name})")
        for m in sorted(by_vlan[vlan], key=lambda x: str(x["mac"])):
            mac = m["mac"]
            name = m["name"]
            lines.append(
                f"tc filter add dev {bridge} egress prio 1 protocol 802.1Q "
                f"flower dst_mac {mac} action vlan pop  # {name}"
            )

    lines.append("")
    lines.append('echo "MAC-based VLAN rules applied successfully"')

    return "\n".join(lines)
