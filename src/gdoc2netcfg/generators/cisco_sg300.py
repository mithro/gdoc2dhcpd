"""Cisco SG300 MAC-based VLAN configuration generator.

Produces switch configuration with MAC-to-VLAN group mappings,
including MAC prefix optimization to fit within the SG300's
256-entry limit.

Extracted from cisco-sg300-vlan.py.
"""

from __future__ import annotations

from dataclasses import dataclass

from gdoc2netcfg.models.addressing import MACAddress
from gdoc2netcfg.models.host import NetworkInventory


@dataclass
class MACVLANEntry:
    """A MAC-to-VLAN mapping entry."""

    mac: MACAddress
    ip: str
    vlan: int
    vlan_name: str
    name: str


@dataclass
class OptimizedEntry:
    """An optimized MAC prefix entry for the SG300."""

    mac: str
    prefix_bits: int
    vlan: int
    names: list[str]
    count: int


BRIDGE_MAC_PREFIX = "02:00:0a:01:"  # Skip bridge MACs
MAC_LIMIT = 256  # SG300 hardware limit


def _get_vlan_name(vlan: int, inventory: NetworkInventory) -> str:
    """Get the VLAN name from the inventory's site config."""
    if vlan in inventory.site.vlans:
        return inventory.site.vlans[vlan].name
    return str(vlan)


def _get_mac_vlan_mappings(inventory: NetworkInventory) -> list[MACVLANEntry]:
    """Extract MAC-to-VLAN mappings from the inventory."""
    seen_macs: dict[str, MACVLANEntry] = {}
    mappings: list[MACVLANEntry] = []

    for host in inventory.hosts:
        for iface in host.interfaces:
            if iface.vlan_id is None:
                continue
            mac_str = str(iface.mac)
            if mac_str.startswith(BRIDGE_MAC_PREFIX):
                continue
            if mac_str in seen_macs:
                continue

            entry = MACVLANEntry(
                mac=iface.mac,
                ip=str(iface.ipv4),
                vlan=iface.vlan_id,
                vlan_name=_get_vlan_name(iface.vlan_id, inventory),
                name=iface.dhcp_name,
            )
            seen_macs[mac_str] = entry
            mappings.append(entry)

    return mappings


def _optimize_mac_entries(mappings: list[MACVLANEntry]) -> list[OptimizedEntry]:
    """Find common MAC prefixes within each VLAN to reduce entry count.

    The SG300 has a 256-entry limit for MAC-to-group mappings. This
    optimization finds common prefixes at 40, 32, and 24-bit boundaries
    to compress multiple MACs into a single prefix rule.
    """
    # Group by VLAN
    by_vlan: dict[int, list[MACVLANEntry]] = {}
    for m in mappings:
        by_vlan.setdefault(m.vlan, []).append(m)

    all_macs = {str(m.mac): m.vlan for m in mappings}
    optimized: list[OptimizedEntry] = []

    for vlan, vlan_macs in by_vlan.items():
        remaining = {str(m.mac) for m in vlan_macs}
        mac_to_entry = {str(m.mac): m for m in vlan_macs}

        for prefix_bits in [40, 32, 24]:
            if not remaining:
                break

            prefix_groups: dict[int, list[str]] = {}
            for mac_str in remaining:
                mac = MACAddress.parse(mac_str)
                prefix = mac.prefix(prefix_bits)
                prefix_groups.setdefault(prefix, []).append(mac_str)

            for prefix, group_macs in prefix_groups.items():
                if len(group_macs) < 2:
                    continue

                # Check for cross-VLAN conflicts
                conflict = False
                for other_mac, other_vlan in all_macs.items():
                    if other_vlan != vlan:
                        if MACAddress.parse(other_mac).prefix(prefix_bits) == prefix:
                            conflict = True
                            break

                if conflict:
                    continue

                prefix_mac = str(MACAddress.from_int(prefix))
                names = [mac_to_entry[m].name for m in sorted(group_macs)]
                optimized.append(OptimizedEntry(
                    mac=prefix_mac,
                    prefix_bits=prefix_bits,
                    vlan=vlan,
                    names=names,
                    count=len(group_macs),
                ))
                remaining -= set(group_macs)

        # Add remaining MACs as individual /48 entries
        for mac_str in sorted(remaining):
            entry = mac_to_entry[mac_str]
            optimized.append(OptimizedEntry(
                mac=mac_str,
                prefix_bits=48,
                vlan=vlan,
                names=[entry.name],
                count=1,
            ))

    return optimized


def generate_cisco_sg300(inventory: NetworkInventory) -> str:
    """Generate Cisco SG300 MAC-based VLAN configuration."""
    mappings = _get_mac_vlan_mappings(inventory)
    optimized = _optimize_mac_entries(mappings)

    lines = [
        "! Cisco SG300 MAC-based VLAN configuration",
        "! Generated by gdoc2netcfg",
        f"! {len(mappings)} MACs optimized to {len(optimized)} entries",
        "!",
    ]

    # Group by VLAN
    by_vlan: dict[int, list[OptimizedEntry]] = {}
    for entry in optimized:
        by_vlan.setdefault(entry.vlan, []).append(entry)

    # VLAN database mode
    lines.append("vlan database")
    lines.append("! Create VLANs")
    for vlan in sorted(by_vlan.keys()):
        lines.append(f"vlan {vlan}")

    # Clear existing MAC mappings
    lines.append("")
    lines.append("! Clear all existing MAC mappings (original /48 entries)")
    for m in sorted(mappings, key=lambda x: str(x.mac)):
        lines.append(f"no map mac {m.mac} 48")

    lines.append("")
    lines.append("! MAC-to-group mappings (prefix/48=exact, /32=4 octets, /24=OUI)")
    for vlan in sorted(by_vlan.keys()):
        vlan_name = _get_vlan_name(vlan, inventory)
        lines.append(f"! Group {vlan} = VLAN {vlan} ({vlan_name})")
        for entry in sorted(by_vlan[vlan], key=lambda x: x.mac):
            lines.append(f"map mac {entry.mac} {entry.prefix_bits} macs-group {vlan}")

    lines.append("exit")
    lines.append("")

    # Interface configuration
    lines.append("! Interface configuration - map macs-groups to VLANs")
    lines.append("! Interfaces must be in general mode")
    lines.append("interface range gigabitethernet1-28")
    lines.append("switchport mode general")
    for vlan in sorted(by_vlan.keys()):
        lines.append(f"switchport general allowed vlan add {vlan} tagged")
    for vlan in sorted(by_vlan.keys()):
        lines.append(f"switchport general map macs-group {vlan} vlan {vlan}")
    lines.append("exit")

    lines.append("")
    lines.append("end")
    lines.append("!")
    lines.append("! To save permanently: write memory")

    # Warning if over limit
    if len(optimized) > MAC_LIMIT:
        lines.insert(3, f"! WARNING: {len(optimized)} entries exceeds limit of {MAC_LIMIT}")

    return "\n".join(lines)
